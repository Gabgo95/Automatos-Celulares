# -*- coding: utf-8 -*-
"""Eng nuclear.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nd2y8jvzDwmhGNDLm8MZjlzPimS060So

#Bibliotecas
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML
from matplotlib.colors import ListedColormap
import random
from collections import defaultdict, Counter
import copy
from matplotlib import colors
import os
import time
from math import sqrt
from statistics import mean, stdev

"""#Jogo da vida"""

# Tamanho da grade
N = 20
grid = np.random.choice([0, 1], size=(N, N))

# Função para atualizar a grade
def update(frameNum, img, grid, N):
    newGrid = grid.copy()
    for i in range(N):
        for j in range(N):
            # Soma dos vizinhos
            total = int((
                grid[i, (j-1)%N] + grid[i, (j+1)%N] +
                grid[(i-1)%N, j] + grid[(i+1)%N, j] +
                grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
                grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N]
            ))
            # Regras
            if grid[i, j] == 1:
                if total < 2 or total > 3:
                    newGrid[i, j] = 0
            else:
                if total == 3:
                    newGrid[i, j] = 1
    img.set_data(newGrid)
    grid[:] = newGrid[:]
    return img,

# Visualização
fig, ax = plt.subplots()
img = ax.imshow(grid, interpolation='nearest', cmap='gray')
ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N), frames=200, interval=100)
plt.show()

# Criar figura
fig, ax = plt.subplots()
img = ax.imshow(grid, interpolation='nearest', cmap='gray')
ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N), frames=200, interval=100)

# Exibir no Colab
HTML(ani.to_jshtml())

"""# Colisão"""

# Tamanho da grade
N = 200

# Estados: 0 = vazio, 1 = norte, 2 = sul, 3 = leste, 4 = oeste
# Cada célula pode conter múltiplas partículas (usamos listas)
grid = [[[] for _ in range(N)] for _ in range(N)]

# Inicializa partículas aleatórias
for _ in range(300):
    i, j = np.random.randint(0, N, size=2)
    direction = np.random.choice([1, 2, 3, 4])
    grid[i][j].append(direction)

# Função para atualizar a grade
def update(frameNum, img, grid, N):
    new_grid = [[[] for _ in range(N)] for _ in range(N)]

    for i in range(N):
        for j in range(N):
            for d in grid[i][j]:
                if d == 1:  # norte
                    new_i = (i - 1) % N
                    new_j = j
                elif d == 2:  # sul
                    new_i = (i + 1) % N
                    new_j = j
                elif d == 3:  # leste
                    new_i = i
                    new_j = (j + 1) % N
                elif d == 4:  # oeste
                    new_i = i
                    new_j = (j - 1) % N
                new_grid[new_i][new_j].append(d)

    # Colisões: se norte e sul na mesma célula → viram leste e oeste
    # se leste e oeste → viram norte e sul
    for i in range(N):
        for j in range(N):
            d = new_grid[i][j]
            if 1 in d and 2 in d:
                new_grid[i][j] = [3, 4]
            elif 3 in d and 4 in d:
                new_grid[i][j] = [1, 2]

    # Visualização: número de partículas por célula
    img.set_data([[len(cell) for cell in row] for row in new_grid])
    for i in range(N):
        for j in range(N):
            grid[i][j] = new_grid[i][j]
    return img,

# Visualização
fig, ax = plt.subplots()
img = ax.imshow([[len(cell) for cell in row] for row in grid], cmap='viridis', interpolation='nearest')
ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N), frames=100, interval=100)

HTML(ani.to_jshtml())

"""#Magnetismo"""

# --- Parâmetros ---
# Tamanho da grade
N = 50

# --- Inicialização ---
# Inicializa a grade com spins aleatórios (+1 ou -1)
grid = np.random.choice([1, -1], size=(N, N))

# --- Funções do Modelo ---
def local_energy(grid, i, j, N):
    """
    Calcula a energia local de um spin na posição (i, j).
    A energia é dada por E = -J * s_i * sum(s_j), onde J=1 e a soma é sobre os vizinhos.
    O sinal negativo no retorno garante que um estado de energia mais baixa (mais alinhado) é favorecido.
    """
    spin = grid[i, j]

    # Vizinhos: cima, baixo, esquerda, direita
    vizinhos = (
        grid[(i - 1 + N) % N, j] + # Vizinho de cima (com condição toroidal)
        grid[(i + 1) % N, j] +     # Vizinho de baixo
        grid[i, (j - 1 + N) % N] + # Vizinho da esquerda
        grid[i, (j + 1) % N]       # Vizinho da direita
    )

    return -spin * vizinhos

def update(frameNum, img, grid, N):
    """
    Atualiza a grade do modelo de Ising seguindo a regra de Monte Carlo (algoritmo de Metropolis).
    Para cada passo, uma célula é escolhida aleatoriamente e seu spin pode ser invertido.
    """
    # A atualização é feita em uma cópia para evitar modificações durante o loop
    # O loop `range(N*N)` garante que, em média, cada spin seja considerado uma vez por iteração
    for _ in range(N * N):
        # Escolhe uma posição aleatória (i, j)
        i, j = np.random.randint(0, N, size=2)

        # Calcula a mudança de energia se o spin for invertido
        delta_E = -2 * local_energy(grid, i, j, N)

        # Se a mudança de energia for negativa, a inversão é sempre aceita
        if delta_E < 0:
            grid[i, j] *= -1
        # Se a mudança for positiva, aceita com uma probabilidade
        # Esta parte é a regra de Monte Carlo (simulação de temperatura) e não estava presente
        # no seu código, que só aceitava mudanças se a energia fosse positiva (o oposto do correto).
        # Para um modelo de "alinhamento" puro, a verificação `delta_E < 0` já é suficiente.

    # A atualização direta de `img.set_data` é o que faltava
    img.set_data(grid)
    return img,

# --- Visualização e Animação ---
fig, ax = plt.subplots(figsize=(6, 6))
img = ax.imshow(grid, cmap='bwr', interpolation='nearest', vmin=-1, vmax=1)
ax.set_xticks([])
ax.set_yticks([])

ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N), frames=100, interval=100)

HTML(ani.to_jshtml())

"""#Propagação de incêndio"""

# --- Parâmetros ---
# Tamanho da grade
N = 50

# Taxas de inicialização
p_arvore = 0.8
p_vazio = 0.2

# --- Inicialização ---
grid = np.random.choice([0, 1], size=(N, N), p=[p_vazio, p_arvore])
grid[N//2, N//2] = 2

# --- Função de Atualização ---
def update(frameNum, img, grid, N):
    new_grid = grid.copy()
    for i in range(N):
        for j in range(N):
            estado_atual = grid[i, j]
            if estado_atual == 1:
                vizinhos = [
                    grid[(i - 1 + N) % N, j],
                    grid[(i + 1) % N, j],
                    grid[i, (j - 1 + N) % N],
                    grid[i, (j + 1) % N]
                ]
                if 2 in vizinhos:
                    new_grid[i, j] = 2
            elif estado_atual == 2:
                new_grid[i, j] = 0

    img.set_data(new_grid)
    grid[:] = new_grid[:]
    return img,

# --- Visualização e Animação ---
# Define a lista de cores para os estados: 0=vazio, 1=árvore, 2=fogo
cores = ["#1A1A1A", "#228B22", "#FF4500"] # Cores em formato hexadecimal
cmap = ListedColormap(cores)

fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xticks([])
ax.set_yticks([])
img = ax.imshow(grid, cmap=cmap, vmin=0, vmax=2, interpolation='nearest')

# Cria a animação
ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N),
                              frames=200, interval=50, blit=True)

HTML(ani.to_jshtml())

"""#Difusão de calor em 2D"""

# --- Parâmetros ---
# Tamanho da grade
N = 50
# Posição da fonte de calor
heat_source_pos = (N // 2, N // 2)
# Intensidade da fonte de calor
HEAT_SOURCE_VALUE = 100

# --- Inicialização ---
# Cria a grade com todos os pontos a zero
grid = np.zeros((N, N))
# Define a fonte de calor no centro
grid[heat_source_pos] = HEAT_SOURCE_VALUE

# --- Função de Atualização (Regra de Difusão) ---
def update(frameNum, img, grid, N, heat_source_pos, heat_source_value):
    """
    Atualiza a grade do modelo de difusão de calor.
    Cada ponto da grade recebe a média da temperatura de seus vizinhos.
    A fonte de calor é mantida constante em sua posição.
    """
    # Cria uma cópia da grade para evitar modificar os valores usados no cálculo
    new_grid = grid.copy()

    # Percorre cada célula da grade
    for i in range(N):
        for j in range(N):
            # A fonte de calor não é alterada.
            # Se for, o calor vai se dissipar em vez de se propagar.
            if (i, j) == heat_source_pos:
                continue

            # Média dos vizinhos (usando condição de contorno periódica/toroidal)
            neighbors_sum = (
                grid[(i - 1 + N) % N, j] +
                grid[(i + 1) % N, j] +
                grid[i, (j - 1 + N) % N] +
                grid[i, (j + 1) % N]
            )

            # A nova temperatura é a média da temperatura dos vizinhos
            new_grid[i, j] = 0.25 * neighbors_sum

    # Atualiza a imagem com os novos dados
    img.set_data(new_grid)
    # Copia a nova grade para a grade original para a próxima iteração
    grid[:] = new_grid[:]
    return img,

# --- Visualização e Animação ---
# Configura a figura e a visualização
fig, ax = plt.subplots(figsize=(6, 6))
# A cor 'hot' é ideal para a visualização de calor
img = ax.imshow(grid, cmap='hot', interpolation='nearest', vmin=0, vmax=HEAT_SOURCE_VALUE)
ax.set_xticks([])
ax.set_yticks([])

# Cria a animação
ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, heat_source_pos, HEAT_SOURCE_VALUE),
                              frames=200, interval=50, blit=True)

# Exibe a animação no notebook
HTML(ani.to_jshtml())

"""#Crescimento tumoral

**Regras Automoto celular**:

Embora as espécies químicas sejam governadas por equações determinísticas de reação-difusão, a evolução das quatro espécies celulares consideradas neste modelo ocorre de acordo com uma combinação de regras probabilísticas e diretas. Estas são descritas a seguir. Assim como em Ferreira et al., consideramos uma simplificação da passivação das células hospedeiras, onde, além do consumo de nutrientes, elas permitem que as células tumorais se dividam e migrem livremente.

Há dois caminhos para morte celular:
1. Morte por insuficiência de nutrientes

$P_{nec} = e^\left[(-\frac{{M}}{T\theta_{nec}})^2\right]$

2. Morte devido ao sistema imune

$P_{im} = 1 - e^{-(\sum_{jϵη}I_j)^2}$


**Solução do modelo**

1. Atribuir valores aos parâmetros, discretizar o domínio espacial e construir as estruturas de dados das células com as condições iniciais.

2. Resolver as equações diferenciais parciais em regime estacionário (steady-state PDEs) que dependem das condições iniciais das células, a fim de obter as concentrações químicas iniciais.

3. Repetir o processo pelo número necessário de passos de tempo, ou até que as condições de parada sejam satisfeitas:

i. Atribuir um número aleatório a todas as localizações da autômato celular (CA), para ser usado na decisão das ações das células.

ii. Para cada posição celular, calcular as probabilidades das ações relevantes da célula (isto é, morte, migração ou divisão da célula tumoral; ou morte, migração e indução da célula imune), dependendo do número aleatório atribuído acima e das concentrações de nutrientes calculadas.

iii. Atualizar as estruturas de dados das células de acordo com as probabilidades e ações aleatórias decididas no passo anterior.

iv. Recalcular as concentrações de nutrientes resultantes das condições celulares modificadas.
v. Parar se o tumor atingir a borda do domínio ou for erradicado; caso contrário, prosseguir para o próximo passo de tempo e retornar ao item (i).
"""

# --- Parâmetros da Simulação ---
N = 100  # Tamanho da grade (maior para melhor visualização)
PROB_CRESCIMENTO = 0.3  # Probabilidade de uma célula tumoral se replicar em um vizinho
THRESHOLD_NECROSE = 4   # Número de vizinhos tumorais para começar a ter necrose
PROB_NECROSE = 0.05     # Probabilidade de uma célula tumoral virar necrótica

# --- Estados da Célula ---
# 0 = Célula Saudável
# 1 = Célula Tumoral
# 2 = Célula Necrótica (morta)
# 3 = célula imunológica

# --- Inicialização da Grade ---
# Começa com todas as células saudáveis
grid = np.zeros((N, N), dtype=int)
# Inicia um pequeno tumor no centro
grid[N // 2 - 1: N // 2 + 1, N // 2 - 1: N // 2 + 1] = 1

# --- Função de Atualização (Regras do Autômato Celular) ---
def update(frameNum, img, grid, N):
    """
    Atualiza a grade com base nas regras de proliferação e necrose do tumor.
    """
    new_grid = grid.copy()

    for i in range(N):
        for j in range(N):
            estado_atual = grid[i, j]

            # Apenas células saudáveis e tumorais podem mudar de estado
            if estado_atual == 2:
                continue # Células necróticas permanecem mortas

            # Conta o número de vizinhos tumorais
            vizinhos_tumorais = 0
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue

                    ni, nj = (i + dx + N) % N, (j + dy + N) % N
                    if grid[ni, nj] == 1:
                        vizinhos_tumorais += 1

            # Regra 1: Proliferação do Tumor
            if estado_atual == 0 and vizinhos_tumorais > 0:
                if np.random.rand() < PROB_CRESCIMENTO:
                    new_grid[i, j] = 1  # Célula saudável vira tumoral

            # Regra 2: Necrose do Tumor (morte celular)
            if estado_atual == 1 and vizinhos_tumorais >= THRESHOLD_NECROSE:
                if np.random.rand() < PROB_NECROSE:
                    new_grid[i, j] = 2  # Célula tumoral vira necrótica

    img.set_data(new_grid)
    grid[:] = new_grid[:]
    return img,

# --- Visualização e Animação ---
# Define o mapa de cores para cada estado
cores = ["#000080", "#FF4500", "#FFFF00"] # Azul escuro, Laranja/Vermelho, Amarelo
cmap = ListedColormap(cores)

fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xticks([])
ax.set_yticks([])
img = ax.imshow(grid, cmap=cmap, vmin=0, vmax=2, interpolation='nearest')

# Cria a animação
ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N),
                              frames=2000, interval=45, blit=True)

# Exibe a animação
HTML(ani.to_jshtml())

# --- Parâmetros da Simulação ---
N = 100
PROB_CRESCIMENTO = 0.2
THRESHOLD_NECROSE = 5
PROB_NECROSE = 0.05

# --- Parâmetros do Tratamento ---
APLICAR_TRATAMENTO = True  # Mude para False para ver o crescimento sem tratamento
# Radioterapia: área de tratamento e probabilidade de morte
RAIO_TRATAMENTO = 20
PROB_MORTE_RADIO = 0.8
# Quimioterapia: probabilidade de morte para todas as células tumorais
PROB_MORTE_QUIMIO = 0.02

# --- Estados da Célula ---
# 0 = Célula Saudável
# 1 = Célula Tumoral
# 2 = Célula Necrótica (morta)

# --- Inicialização da Grade ---
grid = np.zeros((N, N), dtype=int)
grid[N // 2 - 1: N // 2 + 1, N // 2 - 1: N // 2 + 1] = 1

# --- Posição do feixe de radioterapia ---
pos_x_radio, pos_y_radio = N // 2, N // 2

# --- Função de Atualização (Regras do Autômato Celular) ---
def update(frameNum, img, grid, N):
    new_grid = grid.copy()

    for i in range(N):
        for j in range(N):
            estado_atual = grid[i, j]
            if estado_atual == 2:
                continue

            # Conta vizinhos tumorais em um raio de 3x3
            vizinhos_tumorais = 0
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue

                    ni, nj = (i + dx + N) % N, (j + dy + N) % N
                    if grid[ni, nj] == 1:
                        vizinhos_tumorais += 1

            # --- Regras do Crescimento ---
            # Proliferação
            if estado_atual == 0 and vizinhos_tumorais > 0:
                if np.random.rand() < PROB_CRESCIMENTO:
                    new_grid[i, j] = 1

            # Necrose por falta de nutrientes (no centro do tumor)
            if estado_atual == 1 and vizinhos_tumorais >= THRESHOLD_NECROSE:
                if np.random.rand() < PROB_NECROSE:
                    new_grid[i, j] = 2

            # --- Regras do Tratamento ---
            if APLICAR_TRATAMENTO:
                # 1. Radioterapia (ação localizada)
                if estado_atual == 1:
                    distancia = np.sqrt((i - pos_x_radio)**2 + (j - pos_y_radio)**2)
                    if distancia < RAIO_TRATAMENTO:
                        if np.random.rand() < PROB_MORTE_RADIO:
                            new_grid[i, j] = 2

                # 2. Quimioterapia (ação sistêmica)
               # if estado_atual == 1:
                    #if np.random.rand() < PROB_MORTE_QUIMIO:
                       #new_grid[i, j] = 2

    img.set_data(new_grid)
    grid[:] = new_grid[:]
    return img,

# --- Visualização e Animação ---
cores = ["#90EE90", "#DC143C", "#A9A9A9"]
cmap = ListedColormap(cores)

fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xticks([])
ax.set_yticks([])
img = ax.imshow(grid, cmap=cmap, vmin=0, vmax=2, interpolation='nearest')

ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N),
                              frames=300, interval=50, blit=True)

HTML(ani.to_jshtml())

# --- Parâmetros da Simulação e do Tratamento ---
N = 100  # Tamanho da grade
# Níveis de oxigênio (simulados por profundidade no tumor)
OXYGEN_THRESHOLD_HYPOXIC = 10
OXYGEN_THRESHOLD_NECROTIC = 20

# Parâmetros de proliferação e morte
PROB_PROLIFERATION = 0.2  # Probabilidade de célula proliferativa dividir
PROB_DEATH_HYPOXIC = 0.05 # Probabilidade de célula hipóxica morrer

# Parâmetros dos Tratamentos
APPLY_TREATMENT = True
TREATMENT_START_FRAME = 50
RADIOTHERAPY_DOSE = 0.1  # Dano da radioterapia por passo de tempo
HYPERTHERMIA_DOSE = 0.005 # Dano da hipertermia por passo de tempo

# --- Estados da Célula ---
# 0 = Vazio
# 1 = Proliferativa
# 2 = Quiescente
# 3 = Hipóxica
# 4 = Necrótica

# --- Inicialização da Grade ---
grid = np.zeros((N, N), dtype=int)
# Inicia um pequeno tumor proliferativo no centro
center = (N // 2, N // 2)
grid[center] = 1

# --- Função de Atualização (Regras do Autômato Celular) ---
def update(frameNum, img, grid, N):
    new_grid = grid.copy()

    # Aplica o tratamento em um frame específico
    is_treatment_frame = (frameNum >= TREATMENT_START_FRAME) and (APPLY_TREATMENT)

    for i in range(N):
        for j in range(N):
            estado_atual = grid[i, j]

            # Simulação do nível de oxigênio (distância até a borda)
            dist_to_edge = min(i, N-1-i, j, N-1-j)

            # Conta o número de vizinhos
            neighbors_occupied = 0
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0: continue
                    ni, nj = (i + dx + N) % N, (j + dy + N) % N
                    if grid[ni, nj] != 0:
                        neighbors_occupied += 1

            # Regras de Crescimento e Morte
            if estado_atual == 0:  # Célula Vazia
                if neighbors_occupied > 0:
                    # Cresce na borda do tumor (simulando proliferação)
                    if np.random.rand() < PROB_PROLIFERATION:
                        new_grid[i, j] = 1 # Vira Proliferativa

            elif estado_atual == 1: # Célula Proliferativa
                # Transição para quiescente ou hipóxica dependendo do "oxigênio"
                if dist_to_edge > OXYGEN_THRESHOLD_HYPOXIC:
                    new_grid[i, j] = 3 # Vira Hipóxica
                elif dist_to_edge > 0:
                    new_grid[i, j] = 2 # Vira Quiescente

            elif estado_atual == 2: # Célula Quiescente
                # Pode voltar a ser proliferativa se o ambiente melhorar, ou morrer
                if dist_to_edge <= OXYGEN_THRESHOLD_HYPOXIC and np.random.rand() < PROB_PROLIFERATION * 0.5:
                    new_grid[i,j] = 1 # Volta a proliferar
                elif dist_to_edge > OXYGEN_THRESHOLD_NECROTIC:
                    new_grid[i,j] = 4 # Vira necrótica

            elif estado_atual == 3: # Célula Hipóxica
                # Morte por falta de oxigênio
                if np.random.rand() < PROB_DEATH_HYPOXIC:
                    new_grid[i, j] = 4 # Vira necrótica

            # --- Regras de Tratamento (após as regras de crescimento) ---
            if is_treatment_frame and estado_atual in [1, 2, 3]: # Atinge células vivas
                # Efeito da Radioterapia: mata células na área do feixe
                if np.random.rand() < RADIOTHERAPY_DOSE:
                    new_grid[i, j] = 4  # Vira necrótica

                # Efeito da Hipertermia: mata células também
                if np.random.rand() < HYPERTHERMIA_DOSE:
                    new_grid[i, j] = 4  # Vira necrótica

    img.set_data(new_grid)
    grid[:] = new_grid[:]
    return img,

# --- Visualização e Animação ---
# Define o mapa de cores para cada estado
cores = ["#FFFFFF", "#DC143C", "#FFD700", "#FF4500", "#A9A9A9"]
# Branco, Carmesim (Proliferativa), Ouro (Quiescente), Laranja (Hipóxica), Cinza (Necrótica)
cmap = ListedColormap(cores)

fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xticks([])
ax.set_yticks([])
img = ax.imshow(grid, cmap=cmap, vmin=0, vmax=4, interpolation='nearest')

# Cria a animação
ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N),
                              frames=150, interval=50, blit=True)

# Exibe a animação
HTML(ani.to_jshtml())

# --- Parâmetros do Modelo ---
GRID_SIZE = 50            # Tamanho da grade (50x50)
SIMULATION_STEPS = 200    # Número de passos de tempo (iterações)
PROLIFERATION_RATE = 0.3  # Probabilidade de divisão (ajustada para crescimento gradual)
NEIGHBORHOOD = 'Moore'    # 'Moore' (8 vizinhos) ou 'Von Neumann' (4 vizinhos)

# --- Configuração Inicial ---
grid = np.zeros((GRID_SIZE, GRID_SIZE), dtype=int)
center_x, center_y = GRID_SIZE // 2, GRID_SIZE // 2
grid[center_x, center_y] = 1
tumor_size_history = [1]


def get_neighbors(x, y, size, neighborhood_type='Moore'):
    if neighborhood_type == 'Moore':
        offsets = [(-1, -1), (-1, 0), (-1, 1),
                   (0, -1),          (0, 1),
                   (1, -1), (1, 0), (1, 1)]
    elif neighborhood_type == 'Von Neumann':
        offsets = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    else:
        raise ValueError("neighborhood_type deve ser 'Moore' ou 'Von Neumann'")

    neighbors = []
    for dx, dy in offsets:
        nx, ny = x + dx, y + dy
        if 0 <= nx < size and 0 <= ny < size:
            neighbors.append((nx, ny))
    return neighbors


def ca_step(current_grid, neighborhood_type='Moore'):
    """
    Atualiza o estado da grade em um único passo do AC.
    A proliferação ocorre de forma assíncrona: as novas células
    aparecem em uma nova matriz, mas só se baseiam no estado anterior.
    """
    new_grid = np.copy(current_grid)
    GRID_SIZE = current_grid.shape[0]

    # Lista de posições tumorais embaralhada para evitar viés direcional
    tumor_positions = np.argwhere(current_grid == 1)
    np.random.shuffle(tumor_positions)

    for x, y in tumor_positions:
        if random.random() < PROLIFERATION_RATE:
            empty_neighbors = [(nx, ny) for nx, ny in get_neighbors(x, y, GRID_SIZE, neighborhood_type)
                               if current_grid[nx, ny] == 0]
            if empty_neighbors:
                tx, ty = random.choice(empty_neighbors)
                new_grid[tx, ty] = 1

    tumor_size_history.append(np.sum(new_grid == 1))
    return new_grid


# --- Simulação e Visualização ---
print(f"Iniciando simulação ({GRID_SIZE}x{GRID_SIZE}, {SIMULATION_STEPS} passos)...")

plt.ion()
fig, ax = plt.subplots(figsize=(6, 6))

for step in range(SIMULATION_STEPS):
    grid = ca_step(grid, NEIGHBORHOOD)

    if step % 5 == 0 or step == SIMULATION_STEPS - 1:
        ax.clear()
        ax.imshow(grid, cmap='Reds', interpolation='nearest')
        ax.set_title(f"Crescimento Tumoral - Passo {step+1}/{SIMULATION_STEPS}")
        ax.set_xticks([]), ax.set_yticks([])
        plt.pause(0.05)

plt.ioff()
print("\nSimulação concluída!")

# --- Curva de Crescimento ---
plt.figure(figsize=(8, 4))
plt.plot(tumor_size_history, color='darkred', linewidth=2)
plt.title('Dinâmica de Crescimento Tumoral (Autômato Celular)')
plt.xlabel('Passos de Tempo (Iterações)')
plt.ylabel('Tamanho do Tumor (nº de células)')
plt.grid(True)
plt.show()

# --- Estado Final ---
plt.figure(figsize=(6, 6))
plt.imshow(grid, cmap='Reds', interpolation='nearest')
plt.title(f"Estado Final do Tumor (Tamanho: {tumor_size_history[-1]})")
plt.xticks([]), plt.yticks([])
plt.show()

N = 10
grid = np.random.choice([0, 1], size=(N, N))
display(grid)

"""

---

# **Modelagem e Fundamentação Teórica**

A dinâmica de crescimento tumoral foi modelada neste trabalho por meio de um **autômato celular estocástico (CA)** bidimensional, discretizado em espaço e tempo, inspirado nas formulações de Enderling et al. (2009) e formalizado conforme a abordagem desenvolvida por Valentim, Rabi e David (2023). O modelo considera que o tecido tumoral pode ser representado por uma malha regular de células interagindo localmente, na qual cada posição espacial (ou sítio) pode assumir um conjunto finito de estados biológicos. Essa representação discreta permite descrever a proliferação, a migração, a apoptose e a quiescência celular em termos de regras probabilísticas locais, mantendo uma correspondência conceitual direta com os processos contínuos de difusão e reação que governam o crescimento de tumores sólidos.

## **1. Espaço de estados e parâmetros biológicos**

Cada elemento da matriz bidimensional representa uma **micro-região de tecido** com dimensões da ordem de 10 µm, correspondendo aproximadamente ao diâmetro de uma célula individual (Valentim et al., 2023). O estado de cada posição ( (x, y) ) no tempo discreto ( t ) é definido pela variável ( S_t(x,y) ), que pode assumir os seguintes valores:

* $( S_t(x,y) = 0 )$: espaço vazio (matriz extracelular);
* $( S_t(x,y) = p \in [1, P_{\text{max}}] )$: célula tumoral regular (RTC) com potencial proliferativo restante ( p );
* $( S_t(x,y) = P_{\text{max}} + 1 )$: célula-tronco tumoral (STC), biologicamente imortal.

O parâmetro $( P_{\text{max}} )$ representa o **potencial proliferativo máximo** de uma célula regular, análogo ao **limite de Hayflick**, que define o número finito de divisões celulares antes de entrar em senescência (Hayflick & Moorhead, 1961).

O modelo utiliza ainda parâmetros probabilísticos fundamentais:
a probabilidade de proliferação $( P_P = \frac{\Delta t}{CCT} )$, definida como a razão entre o passo de tempo discreto ( \Delta t ) e o tempo médio de ciclo celular ( CCT );
a probabilidade de apoptose ( P_A ), associada à morte celular programada;
a probabilidade de migração ( P_M ), que representa a motilidade celular;
e a probabilidade de divisão simétrica de células-tronco ( P_S ), que controla o equilíbrio entre autorrenovação e diferenciação.

Esses parâmetros, descritos originalmente em Enderling et al. (2009), governam a evolução estocástica do sistema e são escolhidos de modo a reproduzir condições fisiológicas distintas.

## **2. Estrutura espacial e vizinhança celular**

A interação entre células é definida pela **vizinhança de Moore**, composta pelas oito posições adjacentes a um sítio central (horizontal, vertical e diagonal). Essa escolha garante isotropia local e evita anisotropias geométricas artificiais associadas à vizinhança de von Neumann (Valentim et al., 2023).
Matematicamente, a vizinhança $( \mathcal{N}_{x,y} ) $é o conjunto:


$\mathcal{N}_{x,y} = {(x+i, y+j) ;|; i,j \in {-1, 0, 1}, (i,j) \neq (0,0)}$.


A escolha de uma vizinhança aleatória a cada iteração (por embaralhamento de offsets) evita o surgimento de padrões determinísticos de crescimento, garantindo uma difusão efetiva estatisticamente isotrópica.

## **3. Expansão dinâmica do domínio**

Durante a simulação, o tumor pode atingir as fronteiras da grade. Para evitar distorções topológicas e **efeitos de contorno artificiais**, o domínio espacial é expandido automaticamente sempre que células ativas se aproximam das bordas, acrescentando novas camadas de sítios vazios ao redor.
Essa expansão representa, biologicamente, a **invasão tumoral em tecido adjacente** e, matematicamente, corresponde a uma condição de contorno aberta (“open boundary”) na qual o fluxo celular através das fronteiras é livre.

## **4. Regras locais de transição**

A cada passo de tempo discreto, cada célula ativa avalia uma das quatro possíveis ações biológicas, hierarquicamente ordenadas por prioridade:

### **4.1. Apoptose**

A apoptose ocorre sob duas condições:
(i) quando uma célula regular atinge ( p = 1 ), indicando **exaustão replicativa**;
(ii) com probabilidade estocástica ( P_A ), representando **morte programada** induzida por hipóxia, acúmulo de toxinas ou sinais regulatórios negativos.

A célula correspondente é removida do domínio, e seu sítio assume o valor zero. Esse mecanismo é crucial para reproduzir o equilíbrio dinâmico entre proliferação e regressão observado em tumores com necrose central (Hanahan & Weinberg, 2011).

### **4.2. Proliferação**

Com probabilidade ( P_P ), a célula entra em **divisão mitótica**. Se houver espaço livre em sua vizinhança imediata, a célula se divide, e uma das posições vizinhas recebe uma nova célula filha. O potencial proliferativo é decrementado em uma unidade $(( p \to p-1 ))$, refletindo o consumo do potencial replicativo.

O evento de proliferação depende da existência de espaço disponível, traduzindo o princípio biológico de **restrição por contato** (contact inhibition), fundamental no controle do crescimento celular (Abercrombie, 1979).

Para células-tronco tumorais, a proliferação obedece às seguintes regras:

* Com probabilidade $( P_S )$, ocorre **divisão simétrica**, gerando duas STCs e expandindo o compartimento de células imortais;
* Com probabilidade $( 1 - P_S )$, ocorre **divisão assimétrica**, na qual a célula-tronco origina uma STC (que permanece no sítio original) e uma célula regular (RTC) em um vizinho livre.

Essa distinção entre divisões simétricas e assimétricas é essencial para representar a **hierarquia celular tumoral** proposta por Dick (2008), na qual uma fração pequena de STCs mantém o crescimento e a heterogeneidade do tumor.

### **4.3. Migração**

Com probabilidade $( P_M )$, uma célula pode se mover para um vizinho vazio. Esse deslocamento modela o comportamento **motil e invasivo** de células tumorais, dependente de adesão e degradação da matriz extracelular.
Matematicamente, a migração discreta equivale a um termo difusivo $( D\nabla^2 n(x,t) )$ na formulação contínua de densidade celular (Gatenby & Maini, 2003).

A migração tem papel central em cenários de alta motilidade, pois leva à formação de frentes de invasão e padrões morfológicos irregulares observados em tumores agressivos.

### **4.4. Quiescência**

Se nenhuma das regras anteriores é satisfeita, a célula permanece em seu local e mantém o mesmo potencial proliferativo. Esse estado de **quiescência** (fase $G₀)$ é crucial para a manutenção da dormência tumoral — estado no qual o número total de células permanece aproximadamente constante devido ao equilíbrio entre morte e proliferação (Enderling et al., 2009).

---

## **5. Atualização síncrona e competição por espaço**

O modelo adota um esquema de atualização **síncrona**, no qual todas as células avaliam suas ações simultaneamente e as alterações são aplicadas em lote no final de cada iteração.
Quando múltiplas células competem por um mesmo sítio (por exemplo, duas tentando proliferar para o mesmo vizinho), o modelo resolve o conflito escolhendo aleatoriamente um vencedor.
Essa regra de **seleção aleatória equitativa** garante a conservação estatística da densidade celular e evita artefatos espaciais introduzidos pela ordem de varredura.

Formalmente, a dinâmica define uma **cadeia de Markov** discreta sobre o espaço de estados da grade, com transições $( P(S_{t+1}|S_t) )$ determinadas pelas probabilidades $( P_A, P_P, P_M )$ e $( P_S )$.

---

## **6. Interpretação estatística e agregação de réplicas**

A natureza estocástica do autômato implica que cada execução (réplica) corresponde a uma trajetória possível no espaço de estados.
Para obter medidas macroscópicas robustas, várias réplicas independentes são executadas, e as quantidades de interesse — como o número total de células vivas $( N(t) )$ — são calculadas como média e desvio padrão em função do tempo:


$\langle N(t) \rangle = \frac{1}{R} \sum_{r=1}^{R} N_r(t), \quad
\sigma_{N}(t) = \sqrt{\frac{1}{R}\sum_{r=1}^{R}(N_r(t) - \langle N(t) \rangle)^2}$.


Essas médias representam a expectativa do processo de crescimento e permitem comparar diferentes regimes biológicos (alta apoptose, alta migração, alta simetria) com resultados experimentais.

---

## **7. Correspondência com modelos contínuos**

O autômato celular aqui descrito pode ser interpretado como uma discretização estocástica de uma **equação de reação-difusão**, do tipo Fisher–Kolmogorov–Petrovskii–Piskunov (FKPP):


$\frac{\partial n}{\partial t} = D\nabla^2 n + r n \left(1 - \frac{n}{K}\right) - \alpha n,$


onde o termo $( D\nabla^2 n )$ representa migração celular, $( r n (1 - n/K) )$ corresponde à proliferação com saturação de espaço, e $( \alpha n )$ modela apoptose.
Entretanto, o modelo discreto captura fenômenos **heterogêneos e emergentes** que a formulação contínua não descreve adequadamente, como flutuações locais, padrões morfológicos não simétricos e manutenção de subpopulações de STCs (Poleszczuk & Enderling, 2016).

---

## **8. Cenários biológicos simulados**

Cinco conjuntos de parâmetros foram empregados para representar distintos contextos fisiológicos, conforme descrito por Valentim et al. (2023):

1. **Tumor não clonogênico**: ausência de STCs; o tumor cresce e entra em extinção devido à exaustão replicativa.
2. **Tumor clonogênico**: presença de uma STC que apenas gera RTCs; o tumor atinge tamanho estacionário.
3. **Tumor derivado de STC verdadeira**: divisões simétricas ocasionais; crescimento sustentado.
4. **Alta apoptose**: aumento de $ P_A $ reduz a densidade, mas amplia a fração de STCs devido à seleção adaptativa.
5. **Alta migração e simetria**: valores elevados de $( P_M )$ e $( P_S )$ geram morfologia difusa e padrão invasivo.

Cada cenário revela que pequenas alterações nos parâmetros de divisão e morte podem produzir comportamentos macroescópicos qualitativamente distintos, incluindo **dormência**, **colapso** ou **crescimento exponencial**.

---

## **9. Interpretação morfológica**

As visualizações resultantes da simulação são coloridas segundo o potencial proliferativo e o tipo celular:
tons de vermelho representam RTCs, do vermelho escuro (baixa proliferação) ao vermelho claro (alta proliferação);
a cor amarela indica STCs, e o preto corresponde a regiões vazias.

A morfologia emergente apresenta padrões coerentes com observações histológicas reais, incluindo **necrose central**, **bordas proliferativas ativas** e **regiões quiescentes periféricas**, reforçando a validade biológica do modelo (Hanahan & Weinberg, 2011).

---

## **10. Síntese teórico-computacional**

Em termos formais, o autômato implementado é um **sistema dinâmico estocástico discreto** definido por:


$S_{t+1}(x,y) = F(S_t(\mathcal{N}_{x,y}), \xi_t)$,


onde ( F ) é a função de transição que encapsula as regras biológicas, e ( $\xi_t$ ) representa as variáveis aleatórias uniformes independentes.
Esse tipo de formalismo permite capturar a **natureza emergente e não-linear** do crescimento tumoral, em que padrões macroscópicos — como dormência ou invasividade — resultam de interações locais probabilísticas entre células individuais.

Portanto, o modelo desenvolvido constitui uma ferramenta computacional adequada para estudar a **dinâmica espaço-temporal de tumores heterogêneos**, conciliando simplicidade algorítmica com fundamentação biológica quantitativa.

---

### **Referências**

Abercrombie, M. (1979). Contact inhibition and malignancy. *Nature*, 281(5729), 259–262.
Dick, J. E. (2008). Stem cell concepts renew cancer research. *Blood*, 112(13), 4793–4807.
Enderling, H., Anderson, A. R., Chaplain, M. A., Beheshti, A., Hlatky, L., & Hahnfeldt, P. (2009). Paradoxical dependencies of tumor dormancy and progression on basic cell kinetics. *Cancer Research*, 69(22), 8814–8821.
Gatenby, R. A., & Maini, P. K. (2003). Mathematical oncology: cancer summed up. *Nature*, 421(6921), 321.
Hanahan, D., & Weinberg, R. A. (2011). Hallmarks of cancer: the next generation. *Cell*, 144(5), 646–674.
Hayflick, L., & Moorhead, P. S. (1961). The serial cultivation of human diploid cell strains. *Experimental Cell Research*, 25(3), 585–621.
Poleszczuk, J., & Enderling, H. (2016). The optimal stem cell fraction in a tumor. *Mathematical Biosciences and Engineering*, 13(6), 1221–1239.
Valentim, C. A., Rabi, J. A., & David, S. A. (2023). Cellular-automaton model for tumor growth dynamics: Virtualization of different scenarios. *Computers in Biology and Medicine*, 153, 106481.


"""

DEFAULTS = {
    'INITIAL_SIZE': 41,       # inicia 41x41
    'MAX_STEPS': 400,
    'P_MAX': 10,
    'DELTA_T_HOURS': 1.0,
    'CCT_HOURS': 24.0,
    'P_A': 0.0,
    'P_M': 0.10,
    'P_S': 0.05,
    'EXPANSION_MARGIN': 3,
    'EXPANSION_PAD': 12,
    'SEED': 42
}

def set_seed(seed):
    random.seed(seed)
    np.random.seed(seed)

def create_initial_grid(size, p_max, place_stc=False):
    grid = np.zeros((size, size), dtype=int)
    cx, cy = size // 2, size // 2
    grid[cx, cy] = p_max if not place_stc else p_max + 1
    return grid

def get_moore_offsets():
    return [(-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0),  (1, 1)]

def in_bounds(x, y, grid):
    h, w = grid.shape
    return 0 <= x < h and 0 <= y < w

def expand_grid_if_needed(grid, margin, pad):
    if not np.any(grid > 0):
        return grid, (0,0)
    h, w = grid.shape
    coords = np.argwhere(grid > 0)
    min_i = np.min(coords[:,0]); max_i = np.max(coords[:,0])
    min_j = np.min(coords[:,1]); max_j = np.max(coords[:,1])
    need_expand = (min_i <= margin) or (min_j <= margin) or (max_i >= h - 1 - margin) or (max_j >= w - 1 - margin)
    if not need_expand:
        return grid, (0,0)
    new_h = h + pad*2
    new_w = w + pad*2
    new_grid = np.zeros((new_h, new_w), dtype=int)
    new_grid[pad:pad+h, pad:pad+w] = grid
    return new_grid, (pad, pad)

def automaton_step_sync(grid, p_p, p_a, p_m, p_s, p_max, stc_value, seed=None):
    if seed is not None:
        set_seed(seed + int(time.time()*1e6) % 2**32)  # variação por passo se desejar reprodutibilidade por réplica

    h, w = grid.shape
    offsets = get_moore_offsets()
    indices = np.argwhere(grid > 0)
    indices = [tuple(xy) for xy in indices]
    random.shuffle(indices)

    dest_candidates = defaultdict(list)
    stats = {'attempts_prolif':0, 'attempts_mig':0, 'attempts_apop':0}

    N = len(indices)
    rand_apop = np.random.rand(N) if N>0 else np.array([])
    rand_prolif = np.random.rand(N) if N>0 else np.array([])
    rand_mig = np.random.rand(N) if N>0 else np.array([])
    rand_stc_sym = np.random.rand(N) if N>0 else np.array([])

    for idx, (x, y) in enumerate(indices):
        p = grid[x,y]
        if p == 0:
            continue
        # Apoptose por exaustão (RTC)
        if p != stc_value and p == 1:
            dest_candidates[(x,y)].append(('apoptose', (x,y), 0))
            stats['attempts_apop'] += 1
            continue
        # Apoptose estocástica
        if idx < len(rand_apop) and rand_apop[idx] < p_a:
            dest_candidates[(x,y)].append(('apoptose', (x,y), 0))
            stats['attempts_apop'] += 1
            continue
        # Proliferação
        if idx < len(rand_prolif) and rand_prolif[idx] < p_p:
            stats['attempts_prolif'] += 1
            offs = offsets.copy()
            random.shuffle(offs)
            found = False
            for dx, dy in offs:
                nx, ny = x+dx, y+dy
                if in_bounds(nx, ny, grid) and grid[nx, ny] == 0:
                    found = True
                    if p == stc_value:
                        if idx < len(rand_stc_sym) and rand_stc_sym[idx] < p_s:
                            dest_candidates[(nx, ny)].append(('prolif_stc_sym', (x,y), stc_value))
                            dest_candidates[(x,y)].append(('stay_stc', (x,y), stc_value))
                        else:
                            dest_candidates[(nx, ny)].append(('prolif_stc_asym', (x,y), p_max))
                            dest_candidates[(x,y)].append(('stay_stc', (x,y), stc_value))
                    else:
                        new_p = p - 1
                        dest_candidates[(nx, ny)].append(('prolif_rtc_child', (x,y), new_p if new_p>0 else 0))
                        dest_candidates[(x, y)].append(('prolif_rtc_mother', (x,y), new_p if new_p>0 else 0))
                    break
            if found:
                continue
        # Migração
        if idx < len(rand_mig) and rand_mig[idx] < p_m:
            stats['attempts_mig'] += 1
            offs = offsets.copy()
            random.shuffle(offs)
            found = False
            for dx, dy in offs:
                nx, ny = x+dx, y+dy
                if in_bounds(nx, ny, grid) and grid[nx, ny] == 0:
                    dest_candidates[(nx, ny)].append(('migrate', (x,y), p))
                    dest_candidates[(x, y)].append(('vacate', (x,y), 0))
                    found = True
                    break
            if found:
                continue
        # Quiescência
        dest_candidates[(x, y)].append(('stay', (x,y), p))

    new_grid = np.zeros_like(grid)
    for dest, candidates in dest_candidates.items():
        if len(candidates) == 1:
            new_grid[dest] = candidates[0][2]
        else:
            chosen = random.choice(candidates)
            new_grid[dest] = chosen[2]

    return new_grid, stats

# -----------------------------
# Função para rodar réplicas e agregar resultados
# -----------------------------
def run_replicates(n_reps,
                   params,
                   place_stc=False,
                   save_snapshots=False,
                   snapshot_dir='snapshots',
                   verbose=False):
    """
    Executa n_reps réplicas com parâmetros dados em 'params' (dicionário).
    Retorna:
      - series_counts: lista (len = n_reps) de arrays shape (T_max+1,) com contagens totais por tempo
      - histories: lista de listas de grades por réplica (opcionalmente gravadas)
      - aggregated_stats: dicionário com médias e desvios (média por passo e desvio padrão)
    O 'params' deve conter chaves: INITIAL_SIZE, MAX_STEPS, P_MAX, DELTA_T_HOURS, CCT_HOURS, P_A, P_M, P_S, EXPANSION_MARGIN, EXPANSION_PAD, SEED
    """
    set_seed(params.get('SEED', 42))
    histories = []
    series_counts = []
    rep_stats = []

    if save_snapshots and not os.path.exists(snapshot_dir):
        os.makedirs(snapshot_dir)

    for rep in range(n_reps):
        # semente diferente por réplica para variabilidade, mas reproduzível
        seed_rep = params.get('SEED', 42) + rep * 7919
        set_seed(seed_rep)

        grid = create_initial_grid(size=params['INITIAL_SIZE'], p_max=params['P_MAX'], place_stc=place_stc)
        history = [grid.copy()]
        counts = [int(np.sum(grid > 0))]
        stats_list = []

        for step in range(params['MAX_STEPS']):
            grid, offset = expand_grid_if_needed(grid, params['EXPANSION_MARGIN'], params['EXPANSION_PAD'])
            p_p = params['DELTA_T_HOURS'] / params['CCT_HOURS']
            new_grid, stats = automaton_step_sync(grid,
                                                  p_p=p_p,
                                                  p_a=params['P_A'],
                                                  p_m=params['P_M'],
                                                  p_s=params['P_S'],
                                                  p_max=params['P_MAX'],
                                                  stc_value=params['P_MAX']+1,
                                                  seed=seed_rep + step)
            grid = new_grid
            history.append(grid.copy())
            counts.append(int(np.sum(grid > 0)))
            stats_list.append(stats)
            if counts[-1] == 0:
                # tumor extinto cedo; interrompe
                break

        histories.append(history)
        series_counts.append(np.array(counts))
        rep_stats.append(stats_list)

        if verbose:
            print(f"Rep {rep+1}/{n_reps} final_count={counts[-1]} steps={len(counts)-1}")

        if save_snapshots:
            # salva GIF ou PNG da réplica curta (apenas um snapshot final PNG para economizar tempo)
            import imageio
            last = history[-1]
            fname = os.path.join(snapshot_dir, f"rep_{rep+1}_final.png")
            # converte para imagem simples (0 preto; RTC->reds; STC->yellow)
            fig, ax = plt.subplots(figsize=(4,4))
            reds = plt.cm.Reds(np.linspace(0.4,1,params['P_MAX']))
            cmap_list = [(0,0,0,1)] + [tuple(rgb) for rgb in reds] + [(1,1,0,1)]
            cmap = colors.ListedColormap(cmap_list)
            bounds = np.arange(-0.5, (params['P_MAX']+2)-0.5, 1.0)
            norm = colors.BoundaryNorm(bounds, cmap.N)
            ax.imshow(last, cmap=cmap, norm=norm, interpolation='nearest')
            ax.set_xticks([]); ax.set_yticks([])
            plt.savefig(fname, bbox_inches='tight', dpi=150)
            plt.close(fig)

    # Agregar: precisamos padronizar comprimento das séries (variam se tumor extinto cedo)
    max_len = max(len(s) for s in series_counts)
    padded = np.zeros((n_reps, max_len), dtype=float)
    padded[:] = np.nan
    for i, arr in enumerate(series_counts):
        padded[i, :len(arr)] = arr

    mean_series = np.nanmean(padded, axis=0)
    std_series = np.nanstd(padded, axis=0)

    aggregated = {'mean_series': mean_series, 'std_series': std_series, 'padded': padded}
    return histories, series_counts, aggregated

# -----------------------------
# Escolha da réplica representativa
# -----------------------------
def choose_representative(history_list, mean_series):
    """
    Dada uma lista de histories (cada history é lista de grades por tempo) e a mean_series (média de contagens por passo),
    escolhe a réplica cuja série de contagens tem menor soma de quadrados das diferenças até o comprimento da mean_series.
    Retorna índice da réplica representativa.
    """
    best_idx = None
    best_score = float('inf')
    for i, hist in enumerate(history_list):
        counts = np.array([int(np.sum(g>0)) for g in hist])
        # alinhar comprimentos: se menor, preenchido com último valor
        L = len(mean_series)
        counts_padded = np.ones(L) * counts[-1] if len(counts) < L else counts[:L]
        score = np.nansum((counts_padded - mean_series)**2)
        if score < best_score:
            best_score = score
            best_idx = i
    return best_idx

# -----------------------------
# Plotagem agregada e snapshots representativos
# -----------------------------
def plot_aggregate(mean_series, std_series, title, ax=None):
    if ax is None:
        fig, ax = plt.subplots(figsize=(6,4))
    steps = np.arange(len(mean_series))
    ax.plot(steps, mean_series, label='Média (total células)')
    ax.fill_between(steps, mean_series - std_series, mean_series + std_series, alpha=0.3)
    ax.set_xlabel('Passos')
    ax.set_ylabel('Nº células')
    ax.set_title(title)
    ax.grid(True)
    return ax

def plot_snapshot(grid, p_max, title=None):
    reds = plt.cm.Reds(np.linspace(0.4,1,p_max))
    cmap_list = [(0,0,0,1)] + [tuple(rgb) for rgb in reds] + [(1,1,0,1)]
    cmap = colors.ListedColormap(cmap_list)
    bounds = np.arange(-0.5, (p_max+2)-0.5, 1.0)
    norm = colors.BoundaryNorm(bounds, cmap.N)
    fig, ax = plt.subplots(figsize=(4,4))
    ax.imshow(grid, cmap=cmap, norm=norm, interpolation='nearest')
    ax.set_xticks([]); ax.set_yticks([])
    if title:
        ax.set_title(title)
    plt.show()
    return fig, ax

# -----------------------------
# Parâmetros para os 5 cenários (conforme artigo)
# -----------------------------
# Nota: aqui adaptei os valores para manter P_P = DELTA_T / CCT; os parâmetros P_M, P_A, P_S e P_MAX são escolhidos para reproduzir qualitativamente cada cenário.
def make_scenarios():
    base = dict(DEFAULTS)
    scenarios = {}

    # Cenário 1: Tumor originado de célula não clonogênica
    s1 = base.copy()
    s1.update({'INITIAL_SIZE': 41, 'MAX_STEPS': 300, 'P_MAX': 10, 'DELTA_T_HOURS': 1.0, 'CCT_HOURS': 24.0,
               'P_A': 0.0, 'P_M': 10.0/10.0 * 0.1, 'P_S': 0.0})
    scenarios['cenario_1_nonclonogenic'] = {'params': s1, 'place_stc': False, 'label': 'Cenário 1 - não clonogênico'}

    # Cenário 2: Tumor originado por célula clonogênica (STC clonogênica que gera apenas RTC)
    s2 = base.copy()
    s2.update({'INITIAL_SIZE': 41, 'MAX_STEPS': 300, 'P_MAX': 10, 'DELTA_T_HOURS': 1.0, 'CCT_HOURS': 24.0,
               'P_A': 0.0, 'P_M': 10.0/10.0 * 0.1, 'P_S': 0.01})
    # Aqui colocamos uma STC clonogênica no centro (mas que gera RTCs)
    scenarios['cenario_2_clonogenic'] = {'params': s2, 'place_stc': True, 'label': 'Cenário 2 - clonogênico'}

    # Cenário 3: Tumor originado por verdadeira STC (divisão simétrica possível -> P_S maior)
    s3 = base.copy()
    s3.update({'INITIAL_SIZE': 41, 'MAX_STEPS': 400, 'P_MAX': 10, 'DELTA_T_HOURS': 1.0, 'CCT_HOURS': 24.0,
               'P_A': 0.0, 'P_M': 10.0/10.0 * 0.1, 'P_S': 0.05})
    scenarios['cenario_3_true_stc'] = {'params': s3, 'place_stc': True, 'label': 'Cenário 3 - true STC'}

    # Cenário 4: Variação da taxa de apoptose (explorar P_A)
    s4 = base.copy()
    s4.update({'INITIAL_SIZE': 41, 'MAX_STEPS': 400, 'P_MAX': 10, 'DELTA_T_HOURS': 1.0, 'CCT_HOURS': 24.0,
               'P_A': 0.10, 'P_M': 10.0/10.0 * 0.1, 'P_S': 0.01})
    scenarios['cenario_4_high_apoptosis'] = {'params': s4, 'place_stc': True, 'label': 'Cenário 4 - alta apoptose'}

    # Cenário 5: Influência de migração e divisão simétrica (P_M e P_S altos)
    s5 = base.copy()
    s5.update({'INITIAL_SIZE': 41, 'MAX_STEPS': 400, 'P_MAX': 10, 'DELTA_T_HOURS': 1.0, 'CCT_HOURS': 24.0,
               'P_A': 0.01, 'P_M': 0.5, 'P_S': 0.10})
    scenarios['cenario_5_migra_ps_high'] = {'params': s5, 'place_stc': True, 'label': 'Cenário 5 - migração/PS altos'}

    return scenarios

# -----------------------------
# Rotina que executa todos os cenários e plota resultados agregados + snapshots representativos
# -----------------------------
def run_all_scenarios(n_replicates=5, save_snapshots=False, snapshot_dir='snapshots', verbose=True):
    scenarios = make_scenarios()
    results = {}
    for key, info in scenarios.items():
        params = info['params']
        label = info['label']
        place_stc = info['place_stc']
        if verbose:
            print(f"Executando {label} ({key}) com {n_replicates} réplicas...")
        histories, series_counts, aggregated = run_replicates(n_reps=n_replicates,
                                                              params=params,
                                                              place_stc=place_stc,
                                                              save_snapshots=save_snapshots,
                                                              snapshot_dir=snapshot_dir,
                                                              verbose=verbose)
        mean_series = aggregated['mean_series']
        std_series = aggregated['std_series']

        rep_idx = choose_representative(histories, mean_series)
        rep_history = histories[rep_idx] if rep_idx is not None else histories[0]
        rep_final = rep_history[-1]

        # Plota agregada
        fig, ax = plt.subplots(figsize=(6,4))
        plot_aggregate(mean_series, std_series, title=label, ax=ax)
        plt.tight_layout()
        plt.show()

        # Plota snapshot representativo (último quadro da réplica representativa)
        plot_snapshot(rep_final, p_max=params['P_MAX'], title=f"{label} - snapshot representativo (réplica {rep_idx+1})")

        results[key] = {'histories': histories,
                        'series_counts': series_counts,
                        'aggregated': aggregated,
                        'rep_index': rep_idx,
                        'rep_history': rep_history}
    return results

# -----------------------------
# Exemplo de execução (modo script)
# -----------------------------
if __name__ == "__main__":
    # Ajuste N_REPLICATES conforme seu tempo de execução; para resultados robustos, use 50-100 réplicas.
    N_REPLICATES = 5
    set_seed(DEFAULTS['SEED'])
    results = run_all_scenarios(n_replicates=N_REPLICATES, save_snapshots=False, verbose=True)

    # Exemplo: salvar dados agregados para posterior análise
    import pickle
    with open('simulation_results.pkl', 'wb') as f:
        pickle.dump(results, f)
    print("Simulações completas. Resultados salvos em 'simulation_results.pkl'.")